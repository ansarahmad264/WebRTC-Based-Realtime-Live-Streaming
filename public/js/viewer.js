const socket = io();  // Connect to Socket.IO server

const videoElem = document.getElementById('remoteVideo');
const statusElem = document.getElementById('status');
let pc = null;  // RTCPeerConnection for receiving stream

// Notify server that a viewer joined
socket.emit('viewer-join');

// When an offer is received from the host, handle the WebRTC offer/answer process
socket.on('receive-offer', async ({ offer, hostId }) => {
  console.log('Received offer from host:', hostId);
  // Create a peer connection (with STUN server config)
  pc = new RTCPeerConnection({
    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
  });

  // When remote track arrives (hostâ€™s stream), show it in the video element
  pc.ontrack = event => {
    videoElem.srcObject = event.streams[0];
    videoElem.style.display = 'block';      // show video
    statusElem.textContent = '';            // clear "waiting" text
    console.log('Remote stream added to video element.');
  };

  // Send any ICE candidates generated by the viewer to the host
  pc.onicecandidate = event => {
    if (event.candidate) {
      socket.emit('ice-candidate', { candidate: event.candidate, targetId: hostId });
    }
  };

  // Set the host's SDP offer as the remote description for our RTCPeerConnection
  await pc.setRemoteDescription(new RTCSessionDescription(offer));
  // Create an SDP answer to send back to the host
  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);
  // Send the answer via signaling server
  socket.emit('viewer-answer', { answer: answer, hostId: hostId });
  console.log('Sent SDP answer back to host.');
});

// When an ICE candidate is received from the host, add it to our peer connection
socket.on('ice-candidate', ({ candidate, senderId }) => {
  if (pc) {
    pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(err => {
      console.error('Error adding ICE candidate', err);
    });
  }
});

// Handle the host ending the stream
socket.on('stream-ended', () => {
  alert('The stream has ended.');
  if (pc) {
    pc.close();
    pc = null;
  }
  // Reload the page to reset (or could alternatively display a message and wait)
  window.location.reload();
});

// Allow the viewer to leave manually
function leaveStream() {
  if (pc) {
    pc.close();
    pc = null;
  }
  socket.disconnect();
  alert('You left the stream.');
  // Optionally, redirect to a homepage or simply reload to clear state
  window.location.href = '/';
}
